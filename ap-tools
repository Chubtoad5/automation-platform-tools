#!/bin/bash

# --- USER DEFINED Dell Automation Platform Configuration --- #
AP_VERSION=1.0.0.0
AP_BUNDLE_URL=https://dl.dell.com/FOLDER13508681M/1/DellAutomationPlatform_v1.0.0.0.zip
DOWNLOAD_AP_BUNDLE=false
SKIP_IMAGES_LOADER=false
REGISTRY_PROJECT_NAME=dell-automation
ORCHESTRATOR_NAMESPACE=dell-orchestrator
PORTAL_NAMESPACE=dell-portal 
PORTAL_COOKIE_DOMAIN=edge.lab
ORCHESTRATOR_FQDN=orchestrator.edgehost.edge.lab
PORTAL_FQDN=portal.edgehost.edge.lab
PORTAL_INGRESS_CLASS_NAME=haproxy
ORG_NAME=changeme 
ORG_DESC=changeme 
FIRST_NAME=changeme 
LAST_NAME=changeme
USERNAME=administrator
EMAIL=changeme@example.com
REQUIRED_CPU=16
REQUIRED_MEM_GB=32
REQUIRED_STORAGE_GB=400

# --- USER DEFINED Harbor and NGINX Configuration --- #
HARBOR_VERSION=2.12.2
HARBOR_PORT=443
HARBOR_USERNAME=admin
HARBOR_PASSWORD=Harbor12345
NGINX_HTUSER=admin
NGINX_HTPASS=changeme
NGINX_PORT=4443

# --- USER DEFINED Self-Signed Certificate Configuration for Harbor and NGINX --- #
COUNTRY=US
STATE=MA
LOCATION=HOPKINTON
ORGANIZATION=DELL
NGINX_COMMON_NAME=artifacts.edge.lab
HARBOR_COMMON_NAME=registry.edge.lab
DURATION_DAYS=3650

# --- USER DEFINED Kubernetes Configuration ---#
DEBUG=1
RKE2_VERSION=v1.32.5+rke2r1
CLUSTER_TYPE=single-node
MAX_PODS=180
CNI_TYPE=calico
CLUSTER_CIDR="10.42.0.0/16"
SERVICE_CIDR="10.43.0.0/16"
INSTALL_DNS_UTILITY=true
INSTALL_LOCAL_PATH_PROVISIONER=false
LOCAL_PATH_PROVISIONER_VERSION=v0.0.32
HELM_VERSION=3.12.0
LONGHORN_VERSION=1.9.2
LONGHORN_UI_PORT=31000
METALLB_VERSION=0.15.2
INSTALL_METALLB=true
KUBERNETES_INGRESS_VERSION=1.45.0
HAPROXY_APP_VERSION=3.1.7
INSTALL_HAPROXY=true

# --- INTERNAL VARIABLES - DO NOT EDIT --- #
set -o errexit
set -o nounset
set -o pipefail
ENABLE_CIS=false
INSTALL_INGRESS=false
INSTALL_SERVICELB=false
user_name=${SUDO_USER:-$(whoami)}
SCRIPT_NAME=$(basename "$0")
AIR_GAPPED_MODE=0
OFFLINE_PREP_MODE=0
PUSH_MODE=0
INSTALL_MODE=0
INSTALL_TYPE=""
TLS_SAN_MODE=0
TLS_SAN=""
JOIN_MODE=0
JOIN_TYPE=""
JOIN_TOKEN=""
JOIN_SERVER_FQDN=""
base_dir=$(pwd)
mgmt_ip=$(hostname -I | awk '{print $1}')
mgmt_if=$(ip a |grep "$(hostname -I |awk '{print $1}')" | awk '{print $NF}')
WORKING_DIR="$base_dir/ap-install"
REGISTRY_MODE=0
REGISTRY_INFO=""
REG_FQDN=""
REG_PORT=""
REG_USER=""
REG_PASS=""
REG_CERT_FILE_PATH=""
fqdn_pattern='^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$'
ipv4_pattern='^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
RKE2_CMD_ARGS=""
longhorn_packages=""

# --- USAGE FUNCTION --- #

usage() {
    cat << EOF
Usage: $SCRIPT_NAME [install rke2|ap-bundle|harbor|nginx] [offline-prep] [push] [join server|agent [server-fqdn] [join-token-string]] [-tls-san [server-fqdn-ip]] [-registry [registry:port username password]]

Commands:
  install      : Installs specified component and any dependencies.
                 For air-gapped install, ap-offline.tar.gz file must be in the same directory as script.
                  [rke2]       Installs rke2 as a server.
                  [ap-bundle] Extracts the Dell Automation Platform install bundle and outputs the install command. 
                               Must be used with [-registry].
                  [harbor]     Installs the harbor registry.
                  [nginx]      Installs an nginx static file server.
  offline-prep : Creates an offline tar package which contains all dependencies for an air-gapped installation.
                 Cannot be used with [install] [push] [join].
  push         : Pushes all kubernetes and utility container images to the specified registry. 
                 [-registry] must be specified. Does not push Dell Automation Platform images.
  join         : Joins the host to an existing cluster as a [server] or [agent]. 
                 [server-fqdn] and [join-token-string] must be specified.
  -tls-san     : When provided,adds specified FQDN to rke2 tls-san configuration for multi-node setup. 
                 Used with [install rke2] or [join server]. [server-fqdn-ip] must be a valid IP or FQDN.
  -registry    : Used with [install rke2], [install ap-bundle], and [push] to provide a valid registry and credentials.

EOF
    exit 1
}

# Displays the parsed and validated arguments
display_args() {
    echo "### Automation Tools Started on $(date) ###"
    echo "  AIR_GAPPED_MODE: $AIR_GAPPED_MODE"
    echo "  INSTALL_MODE: $INSTALL_MODE"
    echo "  INSTALL_TYPE: $INSTALL_TYPE"
    echo "  TLS_SAN_MODE: $TLS_SAN_MODE"
    echo "  TLS_SAN: $TLS_SAN"
    echo "  OFFLINE_PREP_MODE: $OFFLINE_PREP_MODE"
    echo "  JOIN_MODE: $JOIN_MODE"
    echo "  JOIN_TYPE: $JOIN_TYPE"
    echo "  JOIN_SERVER_FQDN: $JOIN_SERVER_FQDN"
    echo "  JOIN_TOKEN: $JOIN_TOKEN"
    echo "  PUSH_MODE: $PUSH_MODE"
    echo "  REGISTRY_MODE: $REGISTRY_MODE"
    echo "  REGISTRY_INFO: $REGISTRY_INFO"
    echo "  REG_USER: $REG_USER"
    echo "  REG_PASS: $REG_PASS"
    echo "---"
}

build_command_syntax() {
    local install="$INSTALL_MODE"
    local push="$PUSH_MODE"
    local reg="$REGISTRY_MODE"
    local tls="$TLS_SAN_MODE"
    local join="$JOIN_MODE"
    if [[ $JOIN_TYPE == "agent" ]]; then
        local agent="1"
    else
        local agent="0"
    fi
    if [[ $JOIN_TYPE == "server" ]]; then
        local server="1"
    else
        local server="0"
    fi
    local key=""
    key="${install}${push}${reg}${tls}${join}${agent}${server}"
    # Use a case statement on the binary key to find the corresponding syntax
    case "$key" in
        # install
        1000000) RKE2_CMD_ARGS="install" ;;
        # install tls
        1001000) RKE2_CMD_ARGS="install -tls-san $TLS_SAN" ;;
        # install push reg
        1110000) RKE2_CMD_ARGS="install push -registry $REGISTRY_INFO $REG_USER $REG_PASS" ;;
        # install push reg tls
        1111000) RKE2_CMD_ARGS="install push -registry $REGISTRY_INFO $REG_USER $REG_PASS -tls-san $TLS_SAN" ;;
        # install reg
        1010000) RKE2_CMD_ARGS="install -registry $REGISTRY_INFO $REG_USER $REG_PASS" ;;
        # install reg tls
        1011000) RKE2_CMD_ARGS="install -registry $REGISTRY_INFO $REG_USER $REG_PASS -tls-san $TLS_SAN" ;;
        # push reg
        0110000) RKE2_CMD_ARGS="push -registry $REGISTRY_INFO $REG_USER $REG_PASS" ;;
        # join agent
        0000110) RKE2_CMD_ARGS="join agent $JOIN_SERVER_FQDN $JOIN_TOKEN" ;;
        # join agent reg
        0010110) RKE2_CMD_ARGS="join agent $JOIN_SERVER_FQDN $JOIN_TOKEN -registry $REGISTRY_INFO $REG_USER $REG_PASS" ;;
        # join server
        0000101) RKE2_CMD_ARGS="join server $JOIN_SERVER_FQDN $JOIN_TOKEN" ;;
        # join server reg
        0010101) RKE2_CMD_ARGS="join server $JOIN_SERVER_FQDN $JOIN_TOKEN -registry $REGISTRY_INFO $REG_USER $REG_PASS" ;;
        # join server reg tls
        0011101) RKE2_CMD_ARGS="join server $JOIN_SERVER_FQDN $JOIN_TOKEN -registry $REGISTRY_INFO $REG_USER $REG_PASS -tls-san $TLS_SAN" ;;
        # join server tls
        0001101) RKE2_CMD_ARGS="join server $JOIN_SERVER_FQDN $JOIN_TOKEN -tls-san $TLS_SAN" ;;
        # Default case for invalid/unsupported combinations
        *)
            echo "ERROR: Invalid combination of arguments. - $key - Please check usage."
            return 1 # Return non-zero to indicate error
            ;;
    esac
    echo "  parsed command args: $RKE2_CMD_ARGS"
    return 0
}
# --- End of Argument Parsing --- #

# -- Install, Join, Push Definitions -- #

run_install_join_push () {
  run_debug build_command_syntax
  check_rke2_service_running
  if [[ $INSTALL_LOCAL_PATH_PROVISIONER == "false" ]]; then
    if [[ "${OS_ID}" =~ ^(ubuntu|debian)$ ]] || [[ "${OS_ID_LIKE}" =~ (debian|ubuntu) ]]; then
      longhorn_packages="nfs-common open-iscsi cryptsetup"
    elif [[ "${OS_ID}" =~ ^(rhel|centos|rocky|almalinux|fedora)$ ]] || [[ "${OS_ID_LIKE}" =~ (rhel|fedora|centos) ]]; then
      longhorn_packages="nfs-utils iscsi-initiator-utils cryptsetup"
    elif [[ "${OS_ID}" =~ ^(sles|opensuse-leap)$ ]] || [[ "${OS_ID_LIKE}" =~ (suse|sles) ]]; then
      longhorn_packages="nfs-client open-iscsi cryptsetup"
    fi
  fi
  if [[ $AIR_GAPPED_MODE == "1" ]]; then
    if [[ ! -d $base_dir/ap-install ]]; then
      echo "Error: Air-gapped archive detected, but 'ap-install' directory not found. Extract with 'tar xzf ap-offline.tar.gz' first."
      exit 1
    fi
    echo "  Installing dependancy packages..."
    cd $WORKING_DIR/ap-utilities/packages
    ./install_packages.sh offline jq zip unzip $longhorn_packages
    echo "  Running Kubernetes install in air-gapped mode"
    cd $WORKING_DIR/rke2
    tar xzf rke2-save.tar.gz
    RKE2_VERSION=$RKE2_VERSION CNI_TYPE=$CNI_TYPE ENABLE_CIS=$ENABLE_CIS CLUSTER_CIDR=$CLUSTER_CIDR SERVICE_CIDR=$SERVICE_CIDR MAX_PODS=$MAX_PODS INSTALL_INGRESS=$INSTALL_INGRESS INSTALL_SERVICELB=$INSTALL_SERVICELB INSTALL_LOCAL_PATH_PROVISIONER=$INSTALL_LOCAL_PATH_PROVISIONER LOCAL_PATH_PROVISIONER_VERSION=$LOCAL_PATH_PROVISIONER_VERSION INSTALL_DNS_UTILITY=$INSTALL_DNS_UTILITY INSTALL_METALLB=$INSTALL_METALLB DEBUG=$DEBUG ./rke2_installer.sh $RKE2_CMD_ARGS
    cd $base_dir
    echo "  Kubernetes installation completed"
  else
    echo "  Installing dependancy packages..."
    install_packages_check
    cd $WORKING_DIR/ap-utilities/packages
    ./install_packages.sh online jq zip unzip $longhorn_packages
    echo "  Running Kubernetes install with online mode"
    rke2_installer_check
    if [[ $PUSH_MODE == "1" ]]; then
      generate_images_file
    fi
    cd $WORKING_DIR/rke2
    RKE2_VERSION=$RKE2_VERSION CNI_TYPE=$CNI_TYPE ENABLE_CIS=$ENABLE_CIS CLUSTER_CIDR=$CLUSTER_CIDR SERVICE_CIDR=$SERVICE_CIDR MAX_PODS=$MAX_PODS INSTALL_INGRESS=$INSTALL_INGRESS INSTALL_SERVICELB=$INSTALL_SERVICELB INSTALL_LOCAL_PATH_PROVISIONER=$INSTALL_LOCAL_PATH_PROVISIONER LOCAL_PATH_PROVISIONER_VERSION=$LOCAL_PATH_PROVISIONER_VERSION INSTALL_DNS_UTILITY=$INSTALL_DNS_UTILITY INSTALL_METALLB=$INSTALL_METALLB DEBUG=$DEBUG ./rke2_installer.sh $RKE2_CMD_ARGS
    cd $base_dir
    echo "  Kubernetes installation completed"
  fi
  if [[ $INSTALL_TYPE == "rke2" ]]; then
   echo "  Installing dependancy helm charts"
    export KUBECONFIG=/home/$user_name/.kube/config
    export PATH=$PATH:/var/lib/rancher/rke2/bin
    run_debug install_helm
    if [[ $INSTALL_HAPROXY == "true" ]]; then
      echo "  Installing haproxy helm chart..."
      run_debug helm_install_haproxy
    fi
    if [[ $INSTALL_METALLB == "true" ]]; then
      echo "  Installing metallb helm chart..."
      run_debug helm_install_metallb
    fi
    if [[ $INSTALL_LOCAL_PATH_PROVISIONER == "false" ]]; then
      echo "  Installing longhorn helm chart..."
      run_debug helm_install_longhorn
    fi
    echo "  Finished installing dependancy helm charts"
  fi
}

run_install_nginx () {
  cd $WORKING_DIR/ap-utilities/nginx
  if [[ $AIR_GAPPED_MODE == "0" ]]; then
      curl -OL https://github.com/Chubtoad5/nginx-static-files/raw/refs/heads/main/install_nginx.sh
      chmod +x install_nginx.sh
      INSTALL_SERVER=true OFFLINE_PREP=false NGINX_PORT=$NGINX_PORT NGINX_COMMON_NAME=$NGINX_COMMON_NAME NGINX_HTUSER=$NGINX_HTUSER NGINX_HTPASS=$NGINX_HTPASS DURATION_DAYS=$DURATION_DAYS STATE=$STATE COUNTRY=$COUNTRY LOCATION=$LOCATION ORGANIZATION=$ORGANIZATION DEBUG=$DEBUG ./install_nginx.sh
  else
      for file in "$WORKING_DIR/ap-utilities/nginx/nginx_offline_install-*.tar.gz"; do
        tar xzf $file
      done
      INSTALL_SERVER=true OFFLINE_PREP=true NGINX_PORT=$NGINX_PORT NGINX_COMMON_NAME=$NGINX_COMMON_NAME NGINX_HTUSER=$NGINX_HTUSER NGINX_HTPASS=$NGINX_HTPASS DURATION_DAYS=$DURATION_DAYS STATE=$STATE COUNTRY=$COUNTRY LOCATION=$LOCATION ORGANIZATION=$ORGANIZATION DEBUG=$DEBUG ./install_nginx.sh
  fi
}

run_install_harbor () {
  cd $WORKING_DIR/ap-utilities/harbor
  if [[ $AIR_GAPPED_MODE == "0" ]]; then
      curl -OL https://github.com/Chubtoad5/harbor-registry-installer/raw/refs/heads/main/install_harbor.sh
      chmod +x install_harbor.sh
      HARBOR_VERSION=$HARBOR_VERSION HARBOR_PORT=$HARBOR_PORT HARBOR_USERNAME=$HARBOR_USERNAME HARBOR_PASSWORD=$HARBOR_PASSWORD COUNTRY=$COUNTRY STATE=$STATE LOCATION=$LOCATION ORGANIZATION=$ORGANIZATION DURATION_DAYS=$DURATION_DAYS REGISTRY_COMMON_NAME=$HARBOR_COMMON_NAME DEBUG=$DEBUG ./install_harbor.sh install-harbor
  else
      for file in "$WORKING_DIR/ap-utilities/harbor/harbor-offline-package.tar.gz"; do
        tar xzf $file
      done
            HARBOR_VERSION=$HARBOR_VERSION HARBOR_PORT=$HARBOR_PORT HARBOR_USERNAME=$HARBOR_USERNAME HARBOR_PASSWORD=$HARBOR_PASSWORD COUNTRY=$COUNTRY STATE=$STATE LOCATION=$LOCATION ORGANIZATION=$ORGANIZATION DURATION_DAYS=$DURATION_DAYS REGISTRY_COMMON_NAME=$HARBOR_COMMON_NAME DEBUG=$DEBUG ./install_harbor.sh install-harbor
  fi
}

install_helm () {
  echo "  Installing helm..."
  if [[ $AIR_GAPPED_MODE == "0" ]]; then
    curl -fsSLo $WORKING_DIR/ap-utilities/helm/helm-v$HELM_VERSION-linux-amd64.tar.gz https://get.helm.sh/helm-v$HELM_VERSION-linux-amd64.tar.gz
  fi
    tar -xvf $WORKING_DIR/ap-utilities/helm/helm-v$HELM_VERSION-linux-amd64.tar.gz
    mv linux-amd64/helm /usr/local/bin/helm
    rm -rf linux-amd64
    echo "  Adding helm charts..."
    /usr/local/bin/helm repo add metallb https://metallb.github.io/metallb
    /usr/local/bin/helm repo add haproxytech https://haproxytech.github.io/helm-charts
    /usr/local/bin/helm repo add longhorn https://charts.longhorn.io
    /usr/local/bin/helm repo update
}

helm_install_haproxy () {
  cat << EOF > $WORKING_DIR/ap-utilities/helm/haproxy/haproxy-values.yaml
controller:
  image:
    pullPolicy: IfNotPresent
  service:
    type: LoadBalancer
  config:
    ssl-passthrough: "true"
  hostNetwork: true
  kind: DaemonSet
  defaultTLSSecret:
     enabled: false
EOF
  if [[ $AIR_GAPPED_MODE == "0" ]]; then
    /usr/local/bin/helm install haproxy-ingress haproxytech/kubernetes-ingress --create-namespace --namespace haproxy-controller --version $KUBERNETES_INGRESS_VERSION --set controller.image.tag=$HAPROXY_APP_VERSION -f $WORKING_DIR/ap-utilities/helm/haproxy/haproxy-values.yaml
  else
    /usr/local/bin/helm install haproxy-ingress $WORKING_DIR/ap-utilities/helm/haproxy/kubernetes-ingress-$KUBERNETES_INGRESS_VERSION.tgz --namespace haproxy-controller --create-namespace -f $WORKING_DIR/ap-utilities/helm/haproxy/haproxy-values.yaml
  fi
  check_namespace_pods_ready "haproxy-controller"
}

helm_install_longhorn () {
  local values_yaml=""
  if [[ $CLUSTER_TYPE == "single-node" ]]; then
    cat << EOF > $WORKING_DIR/ap-utilities/helm/longhorn/longhorn-values.yaml
# UI Deployment Replica Count
longhornUI:
  replicas: 1
# CSI Components Replica Counts
csi:
  attacherReplicaCount: 1
  provisionerReplicaCount: 1
  resizerReplicaCount: 1
  snapshotterReplicaCount: 1
# Default Settings for new volumes (via Longhorn API/UI)
defaultSettings:
  defaultReplicaCount: 1
  storageReservedPercentageForDefaultDisk: 10
  storageOverProvisioningPercentage: 100
  storageMinimalAvailablePercentage: 5
# Default setting for the Longhorn StorageClass
persistence:
  defaultClassReplicaCount: 1
EOF
    local values_yaml="-f $WORKING_DIR/ap-utilities/helm/longhorn/longhorn-values.yaml"
  fi
  if [[ $AIR_GAPPED_MODE == "0" ]]; then
    /usr/local/bin/helm install longhorn longhorn/longhorn --namespace longhorn-system --create-namespace --version $LONGHORN_VERSION $values_yaml
    echo "  Installing longhornctl binary..."
    curl -L https://github.com/longhorn/cli/releases/download/v$LONGHORN_VERSION/longhornctl-linux-amd64 -o $WORKING_DIR/ap-utilities/helm/longhorn/longhornctl
    chmod +x $WORKING_DIR/ap-utilities/helm/longhorn/longhornctl
    mv $WORKING_DIR/ap-utilities/helm/longhorn/longhornctl /usr/local/bin/longhornctl
  else
    /usr/local/bin/helm install longhorn $WORKING_DIR/ap-utilities/helm/longhorn/longhorn-$LONGHORN_VERSION.tgz --namespace longhorn-system --create-namespace $values_yaml
    echo "  Installing longhornctl binary..."
    chmod +x $WORKING_DIR/ap-utilities/helm/longhorn/longhornctl
    mv $WORKING_DIR/ap-utilities/helm/longhorn/longhornctl /usr/local/bin/longhornctl
  fi
  check_namespace_pods_ready "longhorn-system"
  if [[ -n $LONGHORN_UI_PORT ]]; then
    cat << EOF > $WORKING_DIR/ap-utilities/helm/longhorn/longhornNodePort.yaml
apiVersion: v1
kind: Service
metadata:
  name: longhorn-nodeport-svc
  namespace: longhorn-system
spec:
  type: NodePort
  ports:
  - name: http
    nodePort: 31000
    port: 80
    protocol: TCP
    targetPort: http
  selector:
    app: longhorn-ui
  sessionAffinity: None
EOF
    kubectl apply -f $WORKING_DIR/ap-utilities/helm/longhorn/longhornNodePort.yaml
  fi
}

helm_install_metallb () {
  cat << EOF > $WORKING_DIR/ap-utilities/helm/metallb/metallb-config.yaml
apiVersion: metallb.io/v1beta1
kind: IPAddressPool
metadata:
  name: default-ip-pool
  namespace: metallb-system
spec:
  addresses:
    - $mgmt_ip/32
  autoAssign: true
---
apiVersion: metallb.io/v1beta1
kind: L2Advertisement
metadata:
  name: l2-advertisement
  namespace: metallb-system
spec:
  ipAddressPools:
    - default-ip-pool
  interfaces:
    - $mgmt_if
EOF
  if [[ $AIR_GAPPED_MODE == "0" ]]; then
    /usr/local/bin/helm install metallb metallb/metallb --namespace metallb-system --create-namespace --version $METALLB_VERSION 
  else
    /usr/local/bin/helm install metallb $WORKING_DIR/ap-utilities/helm/metallb/metallb-$METALLB_VERSION.tgz --namespace metallb-system --create-namespace
  fi
  check_namespace_pods_ready "metallb-system"
  kubectl apply -f $WORKING_DIR/ap-utilities/helm/metallb/metallb-config.yaml
}

# --- Automation Platform Bundle prep defenitions --- #

ap_bundle_prep () {
  if [[ $INSTALL_TYPE == "ap-bundle" ]]; then
    ap_host_config
    install_reg_docker
    extract_ap_bundle
  fi
}

install_reg_docker () {
  echo "  Running checks for Registry Certificate and Docker engine..."
  image_pull_push_check
  cp $WORKING_DIR/ap-utilities/images/image_pull_push.sh $WORKING_DIR/rke2/rke2-install/rke2-utilities
  cd $WORKING_DIR/rke2/rke2-install/rke2-utilities
  ./image_pull_push.sh reg-cert $REGISTRY_INFO
  if [[ $AIR_GAPPED_MODE == "0" ]]; then
    ./image_pull_push.sh docker
  else 
    for file in "$WORKING_DIR/rke2/rke2-install/rke2-utilities/container_images_*.tar.gz"; do
      ./image_pull_push.sh docker -f $file
    done
  fi
  cd $base_dir
}

extract_ap_bundle () {
  if [[ -f "$WORKING_DIR/bundle/install-upgrade.sh" ]]; then
    echo "  Bundle already extracted."
    chmod +x $WORKING_DIR/bundle/install-upgrade.sh
  else
    if [[ -d $WORKING_DIR/bundle ]]; then
      echo "  Cleaning up existing files..."
      rm -rf $WORKING_DIR/bundle
    fi
    download_ap_bundle
    mkdir $WORKING_DIR/bundle
    if [[ -f $WORKING_DIR/DellAutomationPlatform_v$AP_VERSION.zip ]]; then
      unzip $WORKING_DIR/DellAutomationPlatform_v$AP_VERSION.zip -d $WORKING_DIR/bundle
      rm -rf $WORKING_DIR/DellAutomationPlatform_v$AP_VERSION.zip
    fi
    for file in "$WORKING_DIR/bundle/"DellAutomationPlatform_v$AP_VERSION-*.zip; do
      unzip "$file" -d "$WORKING_DIR/bundle/"
      rm -rf $file
    done
    chmod +x $WORKING_DIR/bundle/install-upgrade.sh
  fi
  if [[ -f "/usr/local/share/ca-certificates/$REG_FQDN.crt" ]]; then
    REG_CERT_FILE_PATH="/usr/local/share/ca-certificates/$REG_FQDN.crt"
  elif [[ -f "/etc/pki/ca-trust/source/anchors/$REG_FQDN.crt" ]]; then
    REG_CERT_FILE_PATH="/etc/pki/ca-trust/source/anchors/$REG_FQDN.crt"
  else
    echo "Error: registry certificate not found."
    exit 1
  fi
}

ap_host_config () {
  echo "  Configuring host settings for Dell Automation Platform..."
  echo -e "fs.inotify.max_user_watches = 1048576\nfs.inotify.max_user_instances = 1024" | tee /etc/sysctl.d/10-ap-orchestrator.conf
  systemctl restart systemd-sysctl
  if [ $? -ne 0 ]; then
    echo "Error: systemd-sysctl.service failed to restart."
    exit 1 
  else
    echo "  systemd-sysctl.service restarted successfully."
  fi
}

# -- Offline Prep Definitions -- #

run_offline_prep () {
    echo "--- Starting offline preparation workflow"
    echo "  Downloading host packages..."
    run_debug download_dap_packages
    echo "  Downloading NGINX binaries..."
    run_debug download_nginx
    echo "  Downloading Harbor binaries..."
    run_debug download_harbor
    echo "  Downloading dependancy helm charts..."
    run_debug download_helm_binaries
    run_debug generate_images_file
    echo "  Downloading RKE2 binaries and images for RKE2 Core, Longhorn, Metallb, HAProxy."
    echo "  This may take several minutes..."
    run_debug download_rke2
    if [[ $DOWNLOAD_AP_BUNDLE == "true" ]]; then
      echo "  Downloading Dell Automation Platform bundle."
      echo "  Approximate download size is 20G. This may take several minutes..."
      run_debug download_ap_bundle
    fi
    echo "  Creating archive..."
    run_debug  create_offline_prep_archive
    echo "--- Offline prep workflow complete"
}

download_nginx () {
  cp $WORKING_DIR/ap-utilities/packages/install_packages.sh $WORKING_DIR/ap-utilities/nginx/nginx
  cd $WORKING_DIR/ap-utilities/nginx
  curl -OL https://github.com/Chubtoad5/nginx-static-files/raw/refs/heads/main/install_nginx.sh
  chmod +x install_nginx.sh
  INSTALL_SERVER=true OFFLINE_PREP=true ./install_nginx.sh
  cd $base_dir
}

download_harbor () {
  cd $WORKING_DIR/ap-utilities/harbor
  curl -OL https://github.com/Chubtoad5/harbor-registry-installer/raw/refs/heads/main/install_harbor.sh
  chmod +x install_harbor.sh
  DEBUG=$DEBUG ./install_harbor.sh offline-prep
  cd $base_dir
}

download_ap_packages () {
  if [[ $INSTALL_LOCAL_PATH_PROVISIONER == "false" ]]; then
    if [[ "${OS_ID}" =~ ^(ubuntu|debian)$ ]] || [[ "${OS_ID_LIKE}" =~ (debian|ubuntu) ]]; then
      longhorn_packages="nfs-common open-iscsi cryptsetup"
    elif [[ "${OS_ID}" =~ ^(rhel|centos|rocky|almalinux|fedora)$ ]] || [[ "${OS_ID_LIKE}" =~ (rhel|fedora|centos) ]]; then
      longhorn_packages="nfs-utils iscsi-initiator-utils cryptsetup"
    elif [[ "${OS_ID}" =~ ^(sles|opensuse-leap)$ ]] || [[ "${OS_ID_LIKE}" =~ (suse|sles) ]]; then
      longhorn_packages="nfs-client open-iscsi cryptsetup"
    fi
  fi
  install_packages_check
  cd $WORKING_DIR/ap-utilities/packages
  ./install_packages.sh save jq zip unzip $longhorn_packages
  cd $base_dir
}

download_rke2 () {
  rke2_installer_check
  cd $WORKING_DIR/rke2
  RKE2_VERSION=$RKE2_VERSION CNI_TYPE=$CNI_TYPE ENABLE_CIS=$ENABLE_CIS CLUSTER_CIDR=$CLUSTER_CIDR SERVICE_CIDR=$SERVICE_CIDR MAX_PODS=$MAX_PODS INSTALL_INGRESS=$INSTALL_INGRESS INSTALL_SERVICELB=$INSTALL_SERVICELB INSTALL_LOCAL_PATH_PROVISIONER=$INSTALL_LOCAL_PATH_PROVISIONER LOCAL_PATH_PROVISIONER_VERSION=$LOCAL_PATH_PROVISIONER_VERSION INSTALL_DNS_UTILITY=$INSTALL_DNS_UTILITY DEBUG=$DEBUG ./rke2_installer.sh save
  cd $base_dir
}

download_helm_binaries () {
  echo "  Downloading helm binary..."
  curl -fsSLo $WORKING_DIR/ap-utilities/helm/helm-v$HELM_VERSION-linux-amd64.tar.gz https://get.helm.sh/helm-v$HELM_VERSION-linux-amd64.tar.gz
  echo "  Installing helm binary..."
  tar -xvf $WORKING_DIR/ap-utilities/helm/helm-v$HELM_VERSION-linux-amd64.tar.gz
  mv linux-amd64/helm /usr/local/bin/helm
  rm -rf linux-amd64
  echo "  Adding helm charts..."
  /usr/local/bin/helm repo add metallb https://metallb.github.io/metallb
  /usr/local/bin/helm repo add haproxytech https://haproxytech.github.io/helm-charts
  /usr/local/bin/helm repo add longhorn https://charts.longhorn.io
  /usr/local/bin/helm repo update
  echo "  Pulling helm charts..."
  # HAPROXY
  cd $WORKING_DIR/ap-utilities/helm/haproxy
  /usr/local/bin/helm pull haproxytech/kubernetes-ingress --version $KUBERNETES_INGRESS_VERSION
  # LONGHORN
  cd $WORKING_DIR/ap-utilities/helm/longhorn
  /usr/local/bin/helm pull longhorn/longhorn --version $LONGHORN_VERSION
  echo "  Downloading longhornctl binary..."
  curl -L https://github.com/longhorn/cli/releases/download/v$LONGHORN_VERSION/longhornctl-linux-amd64 -o longhornctl
  # METALLB
  cd $WORKING_DIR/ap-utilities/helm/metallb
  /usr/local/bin/helm pull metallb/metallb --version $METALLB_VERSION
}

download_ap_bundle () {
  if [[ ! -f $WORKING_DIR/DellAutomationPlatform_v$AP_VERSION.zip ]]; then
    echo "  Downloading on-premise installation bundle..."
    if ! wget --no-check-certificate --user-agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3" -O $WORKING_DIR/DellAutomationPlatform_v$AP_VERSION.zip $AP_BUNDLE_URL; then
      echo "Error: Failed to download on-premise instalation bundle. Verify URL $AP_BUNDLE_URL is correct and internet connection is available."
      exit 1
    fi
  else
    echo "  Automation Platform bundle already downloaded."
  fi
}

generate_images_file () {
  # Haproxy images
  cd $WORKING_DIR/ap-utilities/helm/haproxy
  echo "haproxytech/kubernetes-ingress:$HAPROXY_APP_VERSION" > haproxy-images.txt
  cat haproxy-images.txt >> $WORKING_DIR/rke2/rke2-install/rke2-utilities/images/utility-images.txt
  # Longhorn images
  cd $WORKING_DIR/ap-utilities/helm/longhorn
  curl -OL https://github.com/longhorn/longhorn/releases/download/v$LONGHORN_VERSION/longhorn-images.txt
  cat longhorn-images.txt >> $WORKING_DIR/rke2/rke2-install/rke2-utilities/images/utility-images.txt
  # Metallb images
  cd $WORKING_DIR/ap-utilities/helm/metallb
  curl -OL https://raw.githubusercontent.com/metallb/metallb/v$METALLB_VERSION/config/manifests/metallb-frr.yaml
  grep 'image:' metallb-frr.yaml | awk '{print $2}' | sort -u >> metallb-images.txt
  cat metallb-images.txt >> $WORKING_DIR/rke2/rke2-install/rke2-utilities/images/utility-images.txt
  cd $base_dir
}

create_offline_prep_archive () {
    # saves downloaded files into ap-offline.tar.gz
    echo "  Creating offline archive 'ap-offline.tar.gz'"
    tar -czf ap-offline.tar.gz ap-install ap-tools
}

# --- Helper Functions --- #

ap_preflight_checks () {
  # Check k8s for the required resources and NTP sync
  echo "  Running pre-flight resource checks..."
  ALLOCATABLE_JSON=$(kubectl get nodes -o json | jq -c '{
    cpu: ([.items[]?.status.allocatable.cpu | sub("m"; "")] | add),
    memory: ([.items[]?.status.allocatable.memory | sub("Ki$"; "") | sub("Mi$"; "") | sub("Gi$"; "") | sub("Ti$"; "")] | add),
    storage: ([.items[]?.status.allocatable."ephemeral-storage" | sub("Ki$"; "") | sub("Mi$"; "") | sub("Gi$"; "") | sub("Ti$"; "")] | add)}' || true)
  if [ -z "$ALLOCATABLE_JSON" ] || [ "$ALLOCATABLE_JSON" = "null" ]; then
    echo "Error: Could not retrieve or parse allocatable resource data. Check kubectl connectivity and 'jq' installation."
    exit 1
  fi
  CURRENT_CPU=$(echo "$ALLOCATABLE_JSON" | jq -r '.cpu')
  CURRENT_MEM_KIB=$(echo "$ALLOCATABLE_JSON" | jq -r '.memory')
  CURRENT_STORAGE_B=$(echo "$ALLOCATABLE_JSON" | jq -r '.storage')
  if [ -z "$CURRENT_CPU" ] || [ "$CURRENT_CPU" = "null" ]; then CURRENT_CPU=0; fi
  if [ -z "$CURRENT_MEM_KIB" ] || [ "$CURRENT_MEM_KIB" = "null" ]; then CURRENT_MEM_KIB=0; fi
  if [ -z "$CURRENT_STORAGE_B" ] || [ "$CURRENT_STORAGE_B" = "null" ]; then CURRENT_STORAGE_B=0; fi
  CURRENT_MEM_GB=$(echo "scale=2; $CURRENT_MEM_KIB / 1024 / 1024" | bc)
  CURRENT_STORAGE_GB=$(echo "scale=2; $CURRENT_STORAGE_B / 1024 / 1024 / 1024" | bc)
  EXIT_CODE=0
  if (( $(echo "$CURRENT_CPU < $REQUIRED_CPU" | bc -l) )); then
    echo "Error: Not enough CPU resources available. Required: $REQUIRED_CPU, Available: $CURRENT_CPU"
    EXIT_CODE=1
  fi

  if (( $(echo "$CURRENT_MEM_GB < $REQUIRED_MEM_GB" | bc -l) )); then
    echo "Error: Not enough memory resources available. Required: $REQUIRED_MEM_GB, Available: $CURRENT_MEM_GB"
    EXIT_CODE=1
  fi

  if (( $(echo "$CURRENT_STORAGE_GB < $REQUIRED_STORAGE_GB" | bc -l) )); then
    echo "Error: Not enough storage resources available. Required: $REQUIRED_STORAGE_GB, Available: $CURRENT_STORAGE_GB"
    EXIT_CODE=1
  fi

  if [ $EXIT_CODE -eq 0 ]; then
    echo "🎉 Cluster resource check PASSED."
    echo "  CPU: $CURRENT_CPU"
    echo "  Memory: $CURRENT_MEM_GB GB"
    echo "  Storage: $CURRENT_STORAGE_GB GB"
  else
    echo "🛑 Cluster resource check FAILED. Exiting."
    exit 1
  fi
  # Check NTP status
  ntp_status=$(timedatectl status | awk '/System clock synchronized/ {print $NF}') || true
  ntp_message="NTP is synchronized!"
  if [ "$ntp_status" != "yes" ]; then
    echo "WARNING: NTP is not synchronized! This may cause Kubernetes pod connectivity issues, use the 'timedatectl' command to check the status."
    ntp_message="WARNING: NTP is not synchronized or timedatectl command failed! This may cause Kubernetes pod connectivity issues, use the 'timedatectl' command to check the status."
  fi
}
dns_pre_flight_checks () {
  # Use this function to check DNS resolution where $1, $2, $3, etc... are the FQDNs to lookup
  # local mtls_dns="mtls-$ORCHESTRATOR_FQDN"
  dns_to_check=()
  failed_lookups=()
  while [ "$#" -gt 0 ]; do
    case "$1" in
      *)
        dns_to_check+=("$1")
        shift
        ;;
    esac
  done
  for entry in "${dns_to_check[@]}"; do
    echo "  Running pre-flight dns check for $entry"
    resolved_dns=$(host -t A "$entry" 2>/dev/null | awk '/has address|is an alias/ { print $NF }' | head -n 1) || true
    if [ -z "$resolved_dns" ]; then
      failed_lookups+=("$entry")
      echo "  Failed to resolve $entry"
    else
      echo "  Resolved $entry to $resolved_dns"
    fi
  done
  if [ "${#failed_lookups[@]}" -gt 0 ]; then
    echo "  Error: The following FQDNs could not be resolved:"
    for failed_entry in "${failed_lookups[@]}"; do
      echo "  - $failed_entry"
    done
    echo "  Fix name resolution before proceeding"
    exit 1
  fi
}
create_working_dir () {
    # check for rke2-install directory and supporting directories, then create them
    [ -d "$WORKING_DIR" ] || mkdir -p "$WORKING_DIR"
    [ -d "$WORKING_DIR/ap-utilities/packages" ] || mkdir -p "$WORKING_DIR/ap-utilities/packages"
    [ -d "$WORKING_DIR/ap-utilities/harbor" ] || mkdir -p "$WORKING_DIR/ap-utilities/harbor"
    [ -d "$WORKING_DIR/ap-utilities/nginx/nginx" ] || mkdir -p "$WORKING_DIR/ap-utilities/nginx/nginx"
    [ -d "$WORKING_DIR/ap-utilities/helm/haproxy" ] || mkdir -p "$WORKING_DIR/ap-utilities/helm/haproxy"
    [ -d "$WORKING_DIR/ap-utilities/helm/metallb" ] || mkdir -p "$WORKING_DIR/ap-utilities/helm/metallb"
    [ -d "$WORKING_DIR/ap-utilities/helm/longhorn" ] || mkdir -p "$WORKING_DIR/ap-utilities/helm/longhorn"
    [ -d "$WORKING_DIR/ap-utilities/images" ] || mkdir -p "$WORKING_DIR/ap-utilities/images"
    [ -d "$WORKING_DIR/rke2" ] || mkdir -p "$WORKING_DIR/rke2/rke2-install/rke2-utilities/images"
}


os_check () {
    # Get OS information from /etc/os-release
    if [[ -f /etc/os-release ]]; then
        # shellcheck disable=SC1091
        source /etc/os-release
        OS_ID_LIKE="${ID_LIKE:-}"
        OS_ID="${ID:-}"
    else
        echo "Error: Unknown or unsupported OS $OS_ID."
        exit 1
    fi
    if [[ ! "$OS_ID" =~ ^(ubuntu|debian|rhel|centos|rocky|almalinux|fedora|sles|opensuse-leap)$ ]]; then
        echo "Error: Unknown or unsupported OS $OS_ID."
        exit 1
    fi
}

install_packages_check () {
    if [[ ! -f $WORKING_DIR/ap-utilities/packages/install_packages.sh ]]; then
        echo "  Downloading install_packages.sh..."
        curl -sfL https://github.com/Chubtoad5/install-packages/raw/refs/heads/main/install_packages.sh  -o $WORKING_DIR/ap-utilities/packages/install_packages.sh
        chmod +x $WORKING_DIR/ap-utilities/packages/install_packages.sh
    fi
}

image_pull_push_check () {
    if [[ ! -f $WORKING_DIR/ap-utilities/images/image_pull_push.sh ]]; then
        echo "  Downloading image_pull_push.sh..."
        curl -sfL https://github.com/Chubtoad5/images-pull-push/raw/refs/heads/main/image_pull_push.sh  -o $WORKING_DIR/ap-utilities/images/image_pull_push.sh
        chmod +x $WORKING_DIR/ap-utilities/images/image_pull_push.sh
    fi
}

rke2_installer_check () {
    if [[ ! -f $WORKING_DIR/rke2/rke2_installer.sh ]]; then
        echo "  Downloading rke2_installer.sh..."
        curl -sfL https://github.com/Chubtoad5/rke2-installer/raw/refs/heads/main/rke2_installer.sh  -o $WORKING_DIR/rke2/rke2_installer.sh
        chmod +x $WORKING_DIR/rke2/rke2_installer.sh
    fi
}

check_rke2_service_running () {
    # Check if rke2 service is running
    if systemctl is-active --quiet rke2-server.service; then
        echo "Error: rke2-server service is already runnnig, install cannot proceed."
        exit 1
    fi
    if systemctl is-active --quiet rke2-agent.service; then
        echo "Error: rke2-agent service is already runnnig, install cannot proceed."
        exit 1
    fi
}

check_namespace_pods_ready() {
  # Run this function as 'check_namespace_pods_ready $namespace', no argument will default to kube-system
  local timeout_seconds=300
  local start_time=$(date +%s)
  local ns=${1:-"kube-system"}
  while true; do
    local completed_pods=$(kubectl get pods -n $ns --field-selector status.phase=Succeeded -o name)
    echo "  Checking pod status and removing Completed pods in $ns namespace..."
    for pod_name in $completed_pods; do
      kubectl delete -n $ns "$pod_name" --ignore-not-found
    done
    local current_pods_not_ready=$(kubectl get pods -n $ns --no-headers | awk '{print $2}' | awk -F'/' '{if ($1 != $2) print $0}' | wc -l)
    local elapsed_time=$(($(date +%s) - start_time))
    if [ "$elapsed_time" -ge "$timeout_seconds" ]; then
      echo "Error: Timeout reached after $timeout_seconds seconds. Not all pods are ready." >&2
      kubectl get pods -A
      return 1
    fi
    if [ "$current_pods_not_ready" -eq 0 ]; then
      break
    fi
    echo "  - Wating on $current_pods_not_ready pods..."
    echo "  - Elapsed: ${elapsed_time}s/${timeout_seconds}s"
    sleep 10
  done
  echo "  - All pods are ready in $ns namespace!"
  return 0
}

run_debug() {
  # Use this to hide the output of functions or helper scripts when they are not needed.
  if [ "$DEBUG" = "1" ]; then
    local GREEN=$(tput setaf 2)
    local RED=$(tput setaf 1)
    local NC=$(tput sgr0)
    local CHECKMARK='\u2714'
    local CROSSMARK='\u2717'
    local SUCCESS_MSG=${2:-"Success"}
    local ERROR_MSG=${3:-"Error"}
    echo "--- Running '$*' with DEBUG enabled---"
    "$@"
    local status=$?
    if [ "$status" -eq 0 ]; then
        echo -e "--- DEBUG: Finished '$*' ${GREEN}${CHECKMARK} ${SUCCESS_MSG}${NC} ---"
    else
        echo -e "--- DEBUG: Finished '$*' ${RED}${CROSSMARK} ${ERROR_MSG}${NC} ---" >&2
    fi
    return $status
  else
    # echo "Running '$*'..."
    "$@" > /dev/null 2>&1
    return $?
  fi
}

cleanup () {
    if [[ $INSTALL_MODE -eq 1 || $JOIN_MODE -eq 1 ]]; then
        echo "  Installation detected, no cleanup required..."
    else
        echo "  Cleaning up..."
        rm -rf "$WORKING_DIR"
    fi
}

runtime_outputs () {
  if [[ $INSTALL_TYPE == "rke2" ]]; then
    local join_token=$(cat /var/lib/rancher/rke2/server/node-token)
    echo ""
    echo "### INSTALL FLOW COMPLETED ###"
    echo "###    PRINTING OUTPUTS    ###"
    echo ""
    echo "Kubernetes Cluster information:"
    kubectl get nodes
    echo ""
    echo "API endpoint: https://$mgmt_ip:6443"
    echo ""
    if [[ $TLS_SAN_MODE -eq 1 ]]; then
      echo "TLS-SAN API endpoint: https://$TLS_SAN:6443"
      echo "To manually join more nodes to this cluster use the following config:"
      echo "----"
      echo "server: https://$TLS_SAN:9345"
      echo "token: $join_token"
      echo "----"
    else
      echo "To manually join more nodes to this cluster use the following config:"
      echo "----"
      echo "server: https://$mgmt_ip:9345"
      echo "token: $join_token"
      echo "----"
    fi
    echo "Next steps:"
    echo "  - Run 'source ~/.bashrc' to enable kubectl"
    echo "  - To join another server using this script, run: 'join server [server-fqdn-ip] [join-token-string]'"
    echo "  - To join another agent using this script, run: 'join agent [server-fqdn-ip] [join-token-string]'"
    echo "  - Run 'install ap-bundle -registry [registry:port username password]' to prepare for Dell Automation Platform install"
  fi
  if [[ $PUSH_MODE -eq 1 && $INSTALL_MODE -eq 0 ]]; then
    echo ""
    echo "### PUSH FLOW COMPLETED ###"
    echo "###  PRINTING OUTPUTS   ###"
    echo ""
    echo "RKE2 and dependancy images have been pushed to external registry $REG_FQDN, check the registry to confirm images are present"
    echo "Next steps:"
    echo "  - Run 'install rke2 -registry [registry:port username password]' to install the cluster"
  fi
  if [[ $JOIN_MODE -eq 1 ]]; then
    if [[ $JOIN_TYPE == "server" ]]; then
        echo ""
        echo "### JOIN FLOW COMPLETED ###"
        echo "###  PRINTING OUTPUTS   ###"
        echo ""
        kubectl get nodes
        echo ""
        echo "Next steps:"
        echo "  - Run 'source ~/.bashrc' to enable kubectl"
        echo "  - (Optional) Join a third server to meet kubernetes minimum multi-node requirements."
        echo "  - Run 'install ap-bundle -registry [registry:port username password]' to prepare for Dell Automation Platform install"
    else
        echo "Next steps:"
        echo "  - From a server node, run'kubectl get nodes' and 'kubectl get pods -A' to confirm the agent is ready"
    fi
  fi
  if [[ $INSTALL_TYPE == "ap-bundle" ]]; then
    echo ""
    echo "### BUNDLE PREP FLOW COMPLETED ###"
    echo "###      PRINTING OUTPUTS      ###"
    echo ""
    echo "Dell Automation Platform is ready for installation"
    echo "$ntp_message"
    echo "Next steps:"
    echo "  - Run the following command to install Dell Automation Platform Portal and Orchestrator:"
    echo "----"
  cat << EOF 
sudo $WORKING_DIR/bundle/install-upgrade.sh \\
  EO_HOST=$ORCHESTRATOR_FQDN PORTAL_HOST=$PORTAL_FQDN PORTAL_COOKIE_DOMAIN=$PORTAL_COOKIE_DOMAIN \\
  IMAGE_REG_URL=$REGISTRY_INFO/$REGISTRY_PROJECT_NAME IMAGE_REG_USERNAME=$REG_USER IMAGE_REG_PASSWORD=$REG_PASS \\
  REGISTRY_CERT_FILE_PATH=$REG_CERT_FILE_PATH \\
  SKIP_IMAGES_LOADER=$SKIP_IMAGES_LOADER \\
  NAMESPACE=$ORCHESTRATOR_NAMESPACE PORTAL_NAMESPACE=$PORTAL_NAMESPACE PORTAL_INGRESS_CLASS_NAME=$PORTAL_INGRESS_CLASS_NAME \\
  ORG_NAME=$ORG_NAME ORG_DESC=$ORG_DESC FIRST_NAME=$FIRST_NAME LAST_NAME=$LAST_NAME USERNAME=$USERNAME EMAIL=$EMAIL
EOF
  echo "----"
  fi

}

# --- Main Script Execution --- #

# --- Start Argument parsing and validation --- #

# Check for root privileges
if [[ $EUID -ne 0 ]]; then
   echo "Error: This script must be run with root privileges."
   echo "Type './$SCRIPT_NAME -h' for help."
   exit 1
fi

# Check for no arguments, and show usage if none are provided
if [[ "$#" -eq 0 ]]; then
    echo "Error: No arguments provided."
    usage
fi

# Check for the correct argument syntax
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        -h|--help)
            usage
            ;;
        install)
            INSTALL_MODE=1
            INSTALL_TYPE="${2:-}"
            if [[ -z "$INSTALL_TYPE" || "$INSTALL_TYPE" != "ap-bundle" && "$INSTALL_TYPE" != "rke2" && "$INSTALL_TYPE" != "harbor" && "$INSTALL_TYPE" != "nginx" ]]; then
            # if [[ -z "$INSTALL_TYPE" || ("$INSTALL_TYPE" != "rke2" && "$INSTALL_TYPE" != "ap-bundle") ]]; then
                # echo "Error: 'install' command requires an install type. Format: install [rke2|ap-bundle|harbor|nginx]"
                echo "Error: 'install' command requires an install type. Format: install [rke2|ap-bundle|harbor|nginx]"
                echo "Type './$SCRIPT_NAME -h' for help."
                exit 1
            fi
            shift
            shift
            ;;
        offline-prep)
            OFFLINE_PREP_MODE=1
            shift
            ;;
        push)
            PUSH_MODE=1
            shift
            ;;
        join)
            JOIN_MODE=1
            JOIN_TYPE="${2:-}"
            JOIN_SERVER_FQDN="${3:-}"
            JOIN_TOKEN="${4:-}"
            if [[ -z "$JOIN_TYPE" || "$JOIN_TYPE" != "agent" && "$JOIN_TYPE" != "server" ]]; then
                echo "Error: 'join' command requires a join type. Format: join [server|agent] [server-fqdn] [join-token-string]"
                echo "Type './$SCRIPT_NAME -h' for help."
                exit 1
            fi
            if [[ -z "$JOIN_SERVER_FQDN" ]]; then
                echo "Error: 'join' command requires a server fqdn/ip. Format: join [server|agent] [server-fqdn] [join-token-string]"
                echo "Type './$SCRIPT_NAME -h' for help."
                exit 1
            fi
            if [[ -z "$JOIN_TOKEN" ]]; then
                echo "Error: 'join' command requires a join token. Format: join [server|agent] [server-fqdn] [join-token-string]"
                echo "Type './$SCRIPT_NAME -h' for help."
                exit 1
            fi
            shift
            shift
            shift
            shift
            ;;
        -tls-san)
            TLS_SAN_MODE=1
            TLS_SAN="${2:-}"
            if [[ -z "$TLS_SAN" ]]; then
                echo "Error: '-tls-san' command requires a server fqdn/ip. Format: -tls-san [server-fqdn-ip]"
                echo "Type './$SCRIPT_NAME -h' for help."
                exit 1
            fi
            shift
            shift
            ;;
        -registry)
            REGISTRY_MODE=1
            REGISTRY_INFO="${2:-}"
            REG_USER="${3:-}"
            REG_PASS="${4:-}"
            if [[ -z "$REG_USER" || -z "$REG_PASS" ]]; then
                echo "Error: Registry info requires a username and password. Format: registry [registry:port username password]"
                echo "Type './$SCRIPT_NAME -h' for help."
                exit 1
            fi
            shift
            shift
            shift
            shift
            ;;
        *)
            echo "Error: Invalid argument '$1'."
            usage
            ;;
    esac
done

# Run validation to ensure the correct arguments and modes have been passed.

# Verify AIR_GAPPED_MODE based on ap-offline.tar.gz file presence
[[ ! -f $base_dir/ap-offline.tar.gz ]] || AIR_GAPPED_MODE=1

# Verify OFFLINE_PREP_MODE is not used with other commands or flags
if [[ "$OFFLINE_PREP_MODE" == "1" ]]; then
    if [[ $JOIN_MODE == "1" || $INSTALL_MODE == "1" || $PUSH_MODE == "1" ]]; then
        echo "Error: 'offline-prep' command cannot be used with 'join, install, or push'."
        echo "Type './$SCRIPT_NAME -h' for help."
        exit 1
    fi
    if [[ $TLS_SAN_MODE == "1" || $REGISTRY_MODE == "1" ]]; then
        echo "Error: 'offline-prep' command cannot be used with '-tls-san or -registry'."
        echo "Type './$SCRIPT_NAME -h' for help."
        exit 1
    fi
    if [[ $AIR_GAPPED_MODE == "1" ]]; then
        echo "Error: Air-gapped mode detected,'offline-prep' requires an internet connection."
        echo "Type './$SCRIPT_NAME -h' for help."
        exit 1
    fi
fi

# Verify PUSH_MODE has registry info and not used with JOIN_MODE
if [[ "$PUSH_MODE" == "1"  ]]; then
    if [[ "$JOIN_MODE" == "1" ]]; then
        echo "Error: 'push' command cannot be used with 'join'."
        echo "Type './$SCRIPT_NAME -h' for help."
        exit 1
    fi
    if [[ "$REGISTRY_MODE" == "0" ]]; then
        echo "Error: 'push' command requires registry config. Format: push -registry [registry:port] [username] [password]"
        echo "Type './$SCRIPT_NAME -h' for help."
        exit 1
    fi
    if [[ "$TLS_SAN_MODE" == "1" && "$INSTALL_MODE" == "0" ]]; then
        echo "Error: 'push' command cannot be used with '-tls-san' unless used with 'install rke2'."
        echo "Type './$SCRIPT_NAME -h' for help."
        exit 1
    fi
fi

# Verify 'ap-bundle' params
if [[ "$INSTALL_TYPE" == "ap-bundle" ]]; then
    if [[ "$REGISTRY_MODE" == "0" ]]; then
        echo "Error: 'install ap-bundle' requires registry config. Format: install ap-bundle -registry [registry:port] [username] [password]"
        echo "Type './$SCRIPT_NAME -h' for help."
        exit 1
    fi
fi

# Verify REGISTRY_MODE is an FQDN/IP and port
if [[ "$REGISTRY_MODE" == "1" ]]; then
    if [[ "$REGISTRY_INFO" =~ ^https?:// ]]; then
        echo "Error: registry info must be a valid FQDN or IPv4 format. i.e. 'my.regsitry.com:443'."
        exit 1
    fi
    REG_FQDN=$(echo "$REGISTRY_INFO" | cut -d':' -f1)
    REG_PORT=$(echo "$REGISTRY_INFO" | cut -d':' -f2)
    if [[ ! ( "$REG_FQDN" =~ $fqdn_pattern || "$REG_FQDN" =~ $ipv4_pattern ) ]]; then
        echo "Error: Registry url must be a valid FQDN or IPv4 format. i.e. 'my.regsitry.com' or '192.168.1.50'."
        exit 1
    fi
    if [[ "$REG_PORT" =~ ^[0-9]+$ ]]; then
        if [[ "$REG_PORT" -lt 1 || "$REG_PORT" -gt 65535 ]]; then
            echo "Error: Registry port must be a number between 1 and 65535."
            exit 1
        fi
    else
        echo "Error: Registry port must be a number between 1 and 65535."
        exit 1
    fi
fi

# --- Main Workflow --- $

os_check
display_args
create_working_dir
if [[ $OFFLINE_PREP_MODE == "1" ]]; then
  run_offline_prep
  echo "Offline archive 'ap-offline.tar.gz' created. Copy the archive to an air-gapped host running the same version of $OS_ID"
fi
if [[ ($INSTALL_MODE == "1" || $JOIN_MODE == "1" || $PUSH_MODE == "1") && ($INSTALL_TYPE != "ap-bundle" && $INSTALL_TYPE != "harbor" && $INSTALL_TYPE != "nginx") ]]; then
  [[ $TLS_SAN_MODE == "0" ]] || dns_pre_flight_checks $TLS_SAN
  [[ $REGISTRY_MODE == "0" ]] || dns_pre_flight_checks $REG_FQDN
  run_install_join_push
fi
if [[ $INSTALL_TYPE == "ap-bundle" ]]; then
  echo "  Preparing Dell Automation Platform bundle..."
  echo "  This may take several minutes..."
  mtls_dns="mtls-$ORCHESTRATOR_FQDN"
  dns_pre_flight_checks $PORTAL_FQDN $ORCHESTRATOR_FQDN $mtls_dns $REG_FQDN
  ap_preflight_checks
  ap_bundle_prep
fi
if [[ $INSTALL_TYPE == "nginx" ]]; then
  echo "  Installing NGINX artifact server..."
  run_install_nginx
fi
if [[ $INSTALL_TYPE == "harbor" ]]; then
  echo "  Installing Harbor registry..."
  run_install_harbor
fi
runtime_outputs
echo "### Automation Tools Finished on $(date) ###"
